# Project RoboOrchard
#
# Copyright (c) 2024-2025 Horizon Robotics. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

import os
import re
import subprocess
import warnings

from setuptools import setup

PROJECT_NAME = "robo_orchard_lab"
PYTHON_BASE_DIR = os.path.abspath(os.path.dirname(__file__))

LICENSE_HEADER = """# Project RoboOrchard
#
# Copyright (c) 2024-2025 Horizon Robotics. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
"""


HORIZON_CI = os.environ.get("HORIZON_CI", default="0") == "1"
"""If HORIZON_CI is set to 1, it means we are in the CI environment.
In this case, we will replace the github dependencies with the internal
gitlab url.
"""

ROBO_ORCHARD_USE_LOCAL = (
    os.environ.get("ROBO_ORCHARD_USE_LOCAL", default="0") == "1"
)
"""If ROBO_ORCHARD_USE_LOCAL is set to 1, it means we are in the local
development environment. Any robo_orchard_xxx dependencies will be replaced
with the local path of the package.
"""


class VersionPostfixNotExist(Exception):  # noqa: N818
    pass


def get_version() -> str:
    with open(os.path.join(PYTHON_BASE_DIR, "VERSION"), "r") as fp:
        base_version = fp.read().strip()

    def get_full_version(
        version_postfix_path, throw_if_not_exist: bool = True
    ) -> str:
        if os.path.exists(version_postfix_path):
            with open(version_postfix_path, "r") as fp:
                post_fix = fp.read().strip()
            return f"{base_version}{post_fix}"
        elif throw_if_not_exist:
            raise VersionPostfixNotExist(
                "VERSION_POSTFIX file not found! please call `make version` first"  # noqa: E501
            )
        else:
            warnings.warn(
                "VERSION_POSTFIX file not found! using base version only",
                UserWarning,
            )
            return base_version

    # generate git hash
    try:
        repo_git_hash = subprocess.check_output(
            "git log -1 --pretty=format:%h".split()
        ).decode()
    except subprocess.CalledProcessError:
        # if git command fails, use a placeholder
        warnings.warn(
            "Failed to get git hash, using 'unknown' as placeholder",
            UserWarning,
        )
        repo_git_hash = "unknown"

    version_postfix_path = os.path.join(PYTHON_BASE_DIR, "VERSION_POSTFIX")

    try:
        full_version = get_full_version(version_postfix_path)
    except VersionPostfixNotExist:
        # if VERSION_POSTFIX file not found, check the parent directory
        version_postfix_path = os.path.join(
            os.path.dirname(PYTHON_BASE_DIR), "VERSION_POSTFIX"
        )
        try:
            full_version = get_full_version(version_postfix_path)
        except VersionPostfixNotExist:
            # if still not found, use base version only
            warnings.warn(
                "VERSION_POSTFIX file not found in both current and parent directories! "  # noqa: E501
                "try to using base version.",
                UserWarning,
            )
            full_version = f"{base_version}.dev"

    with open(
        os.path.join(PYTHON_BASE_DIR, PROJECT_NAME, "version.py"), "w"
    ) as fp:  # noqa: E501
        fp.write(LICENSE_HEADER + "\n")
        fp.write(
            '"""This file is auto-generated by setup.py, do not edit it!"""\n\n'  # noqa: E501
        )
        fp.write(f'__version__ = "{base_version}"\n')
        fp.write(f'__full_version__ = "{full_version}"\n')
        fp.write(f'__git_hash__ = "{repo_git_hash}"\n')

    return full_version


def wrap_github_dependency(
    dependencies: list[str] | dict[str, list[str]],
):
    if not HORIZON_CI:
        return dependencies

    replace_pair = (
        "github.com/HorizonRobotics/",
        "jh-gitlab.hobot.cc/dep/robot-lab/open-source/",
    )

    if isinstance(dependencies, list):
        return [dep.replace(*replace_pair) for dep in dependencies]
    elif isinstance(dependencies, dict):
        for k, v in dependencies.items():
            dependencies[k] = [dep.replace(*replace_pair) for dep in v]
        return dependencies
    else:
        raise TypeError(
            "dependencies should be a list or a dict, "
            f"but got {type(dependencies)}"
        )


def handle_local_dependency(
    dependencies: list[str] | dict[str, list[str]],
    base_dir: str = os.path.dirname(PYTHON_BASE_DIR),
):
    if not ROBO_ORCHARD_USE_LOCAL:
        return dependencies

    def replace_local_dependency(dep: str) -> str:
        if not dep.startswith("robo_orchard_"):
            return dep
        if dep.startswith(PROJECT_NAME):
            return dep  # do not replace the current package itself

        # extract full package name from the dependency str.
        # the dependency str could be 'robo_orchard_xxx==xxx',
        # 'robo_orchard_xxx@xxx',  'robo_orchard_xxx',
        # 'robo_orchard_xxx>xxx', or 'robo_orchard_xxx<xxx'.
        match = re.match(r"robo_orchard_(\w+)([<>=@].*)?", dep)
        assert match, f"Invalid dependency format: {dep}"
        package_name = "robo_orchard_" + match.group(1)
        package_full_path = os.path.join(
            base_dir,
            package_name,
        )
        if not os.path.exists(package_full_path):
            raise FileNotFoundError(
                f"Local package {package_full_path} does not exist!"
            )
        # extend the dependenty to 'robo_orchard_xxx @ file://{package_full_path}'
        ret = f"{package_name}@file://{package_full_path}"
        return ret

    if isinstance(dependencies, list):
        return [replace_local_dependency(dep) for dep in dependencies]
    elif isinstance(dependencies, dict):
        for k, v in dependencies.items():
            dependencies[k] = [replace_local_dependency(dep) for dep in v]
        return dependencies
    else:
        raise TypeError(
            "dependencies should be a list or a dict, "
            f"but got {type(dependencies)}"
        )


if __name__ == "__main__":
    install_requires = [
        "pydantic",
        "torch>=2.4.0",
        "torchvision>=0.19.0",
        "numpy<2",  # dependencies may not be compatible with numpy 2.x
        "accelerate>=1.10.1",
        "safetensors>=0.6.2",
        "tqdm",
        "deprecated",
        "timeout-decorator",
        "requests",
        "huggingface_hub",
        # metric
        "torchmetrics>=1.6",
        "datasets>=4.0.0",
        "sqlalchemy",
        "duckdb-engine",
        "duckdb<=1.3.2",
        "fsspec",
        "sortedcontainers",
        "numpydantic",
        # use git url to install the latest version.
        # This is for non-release version only.
        # "robo_orchard_core==0.2.0",
        "robo_orchard_core@git+https://github.com/HorizonRobotics/robo_orchard_core.git@7cfd9e8758cf79c0265730b315e1c905f4466058",
    ]
    # optional dependencies
    extras_require = {
        "bip3d": [
            "transformers<=4.49.0",
            "peft>=0.17.0",
            "terminaltables",
            "pytorch3d",
            "ninja",
        ],
        "sem": [
            "robo_orchard_lab[bip3d]",
            "diffusers",
            "lmdb",
            "pytorch-kinematics",
            "h5py",
        ],
        "mcap_datasets": [
            "mcap-protobuf-support>=0.5.3",
            "mcap-ros2-support",
            "mcap>=1.2.2",
            "foxglove-schemas-protobuf>=0.3.0",
            "opencv-python",
            "robo_orchard_schemas==0.1.1",
        ],
        "aux_think": [
            "transformers",
            "tokenizers",
            "peft",
            "markdown2[all]",
            "scikit-learn>=1.2.2",
            "opencv-python",
            "uvicorn",
            "fastapi",
            "timm",
            "ninja",
            "tyro",
            "loguru",
            "hydra-core",
            "deepspeed",
        ],
        "finegrasp": [
            "scipy",
            "einops",
            "torch-geometric",
            "open3d",
        ],
        "all": [
            "robo_orchard_lab[bip3d,sem,mcap_datasets,aux_think,finegrasp]"
        ],
    }
    install_requires = wrap_github_dependency(install_requires)
    install_requires = handle_local_dependency(install_requires)
    extras_require = wrap_github_dependency(extras_require)
    extras_require = handle_local_dependency(extras_require)

    setup(
        version=get_version(),
        install_requires=install_requires,
        extras_require=extras_require,
    )
